snippet "gen header"
#pragma once

namespace $1{
}
endsnippet

snippet "decl copycons" "Declare copy constructor"
$1($1 const &other) noexcept;
endsnippet

snippet "dele copycons" "Delete copy constructor"
$1($1 const &) = delete;
endsnippet

snippet "decl movecons" "Declare move constructor"
$1($1 &&other) noexcept;
endsnippet

snippet "dele movecons" "Delete move constructor"
$1($1 &&) = delete;
endsnippet

snippet "decl destructor" "Declare destructor"
~$1() noexcept;
endsnippet

snippet "def fd object" "Defind a wrapper object for Linux file descriptor"
class $1 {
public:
	$1($1 const &) = delete;
	$1($1 &&other) noexcept;

	auto operator=($1 const &) -> $1 & = delete;
	auto operator=($1 &&other) noexcept -> $1 &;

	~$1() noexcept;

private:
	$1(int fd) noexcept;

	int m_fd;
};
endsnippet

snippet "def fd functions" "Define special member functions for a wrapper object for Linux file descriptor"
$1::$1($1 &&other) noexcept
    : m_fd{other.m_fd} {
  other.m_fd = -1;
}
auto $1::operator=($1 &&other) noexcept -> $1 & {
  m_fd       = other.m_fd;
  other.m_fd = -1;

  return *this;
}

$1::~$1() noexcept {
  if (m_fd == -1) {
    return;
  }
  ::$2(m_fd);
}

$1::$1(int fd) noexcept
    : m_fd{fd} {}
endsnippet

snippet "map error" "Define function for mapping error to enum members"
[[nodiscard]] ${1:static} constexpr auto map_$2_error(int ${3:error}) noexcept -> $4 {
	switch($3) {
	default: return static_cast<$4>($3);
	}
}
endsnippet
